import "experimental"

// Stats per sensor: middts -> simulator
// Outputs a table with columns: sensor, mean_ms, median_ms, min_ms, max_ms

middts_sent = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "middts")
  |> filter(fn: (r) => r._field == "sent_timestamp")
  |> rename(columns: {_value: "sent_timestamp"})
  |> keep(columns: ["_time", "sensor", "sent_timestamp"])

simulator_recv = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "simulator")
  |> filter(fn: (r) => r._field == "received_timestamp")
  |> rename(columns: {_value: "received_timestamp"})
  |> keep(columns: ["_time", "sensor", "received_timestamp"])

joined = join(tables: {m: middts_sent, s: simulator_recv}, on: ["sensor"]) 
  |> map(fn: (r) => ({
    _time: r._time_s,
    sensor: r.sensor,
    sent_timestamp: r.sent_timestamp,
    received_timestamp: r.received_timestamp,
    latency_ms: float(v: (r.received_timestamp - r.sent_timestamp))
  }))
  |> filter(fn: (r) => exists r.sent_timestamp and exists r.received_timestamp and r.latency_ms >= 0.0)

per_event = joined
  |> group(columns: ["sensor", "received_timestamp"]) 
  |> min(column: "latency_ms")

// Compute each stat as a table with columns: sensor, stat, value
mean_tbl = per_event
  |> group(columns: ["sensor"]) 
  |> mean(column: "latency_ms")
  |> map(fn: (r) => ({ sensor: r.sensor, stat: "mean", value: r._value }))

median_tbl = per_event
  |> group(columns: ["sensor"]) 
  |> quantile(column: "latency_ms", q: 0.5)
  |> map(fn: (r) => ({ sensor: r.sensor, stat: "median", value: r._value }))

min_tbl = per_event
  |> group(columns: ["sensor"]) 
  |> min(column: "latency_ms")
  |> map(fn: (r) => ({ sensor: r.sensor, stat: "min", value: r._value }))

max_tbl = per_event
  |> group(columns: ["sensor"]) 
  |> max(column: "latency_ms")
  |> map(fn: (r) => ({ sensor: r.sensor, stat: "max", value: r._value }))

// Merge stat tables and pivot to produce columns per stat
union(tables: [mean_tbl, median_tbl, min_tbl, max_tbl])
  |> pivot(rowKey:["sensor"], columnKey:["stat"], valueColumn: "value")
  |> map(fn: (r) => ({
    _time: now(),
    sensor: r.sensor,
    mean_ms: r.mean,
    median_ms: r.median,
    min_ms: r.min,
    max_ms: r.max
  }))
  |> yield(name: "latency_stats_middts_to_simulator")
