# Script para pegar a latencia do simulator para o middleware

import "experimental"
simulatorData = from(bucket: "data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "device_data")
  |> filter(fn: (r) => r["source"] == "simulator")
  |> filter(fn: (r) => r["_field"] == "sent_timestamp")
  |> rename(columns: {_value: "sent_timestamp"})
  |> keep(columns: ["_time", "sensor", "sent_timestamp"])
  |> group(columns: ["sensor"])
  |> sort(columns: ["_time"], desc: false)  // Ordena pelo tempo
midttsData = from(bucket: "data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "device_data")
  |> filter(fn: (r) => r["source"] == "middts")
  |> filter(fn: (r) => r["_field"] == "received_timestamp")
  |> rename(columns: {_value: "received_timestamp"})
  |> keep(columns: ["_time", "sensor", "received_timestamp"])
  |> group(columns: ["sensor"])
  |> sort(columns: ["_time"], desc: false)  // Ordena pelo tempo
joinedData = join(
  tables: {simulator: simulatorData, midtts: midttsData},
  on: ["sensor"]
)
  |> filter(fn: (r) => exists r.sent_timestamp and exists r.received_timestamp)  // Garante que os valores existam
  |> filter(fn: (r) => r.received_timestamp > r.sent_timestamp)  // Garante pareamento correto
  |> map(fn: (r) => ({
      _time: r._time,  // Mantém o tempo do evento recebido como referência
      sensor: r.sensor,
      sent_timestamp: r.sent_timestamp,
      received_timestamp: r.received_timestamp,
      latency_ms: float(v: (r.received_timestamp - r.sent_timestamp))  // Calcula a latência correta
  }))
  |> group(columns: ["sensor", "sent_timestamp"])  // Mantém a relação entre envio e recebimento
  |> min(column: "latency_ms")  // Mantém apenas o menor received_timestamp para cada sent_timestamp
  |> yield(name: "latency_simulator_to_middts")
  