// Histograma Comparativo: Distribuição de Latências S2M vs M2S
// Visualiza a distribuição das latências para identificar padrões e outliers
// Útil para análise estatística detalhada das latências URLLC

import "experimental"

// S2M Latency Distribution
s2m_sent = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "simulator")
  |> filter(fn: (r) => r._field == "sent_timestamp")
  |> map(fn: (r) => ({ r with sent_timestamp: r._value }))
  |> keep(columns: ["_time", "sensor", "sent_timestamp"])

s2m_received = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "middts")
  |> filter(fn: (r) => r._field == "received_timestamp")
  |> map(fn: (r) => ({ r with received_timestamp: r._value }))
  |> keep(columns: ["_time", "sensor", "received_timestamp"])

s2m_histogram = join(tables: {s: s2m_sent, r: s2m_received}, on: ["sensor"])
  |> filter(fn: (r) => exists r.sent_timestamp and exists r.received_timestamp)
  |> map(fn: (r) => ({
    _time: r._time_r,
    sensor: r.sensor,
    direction: "S2M",
    latencia_ms: float(v: (r.received_timestamp - r.sent_timestamp)),
    time_diff_ns: int(v: r._time_r) - int(v: r._time_s)
  }))
  |> filter(fn: (r) => r.latencia_ms >= 0.0 and r.latencia_ms < 1000.0)
  |> filter(fn: (r) => r.time_diff_ns >= 0 and r.time_diff_ns < 30000000000)
  |> group(columns: ["sensor", "sent_timestamp"])
  |> min(column: "latencia_ms")
  |> group()
  |> histogram(
      column: "latencia_ms",
      upperBoundColumn: "le",
      countColumn: "_value",
      bins: [0.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 150.0, 200.0, 300.0, 500.0, 1000.0]
    )
  |> map(fn: (r) => ({ r with direction: "S2M" }))

// M2S Latency Distribution
m2s_sent = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "latency_measurement")
  |> filter(fn: (r) => r["source"] == "middts")
  |> filter(fn: (r) => r._field == "sent_timestamp")
  |> map(fn: (r) => ({ r with sent_timestamp: r._value }))
  |> keep(columns: ["_time", "sensor", "sent_timestamp"])

m2s_received = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "latency_measurement")
  |> filter(fn: (r) => r["source"] == "simulator")
  |> filter(fn: (r) => r._field == "received_timestamp")
  |> map(fn: (r) => ({ r with received_timestamp: r._value }))
  |> keep(columns: ["_time", "sensor", "received_timestamp"])

m2s_histogram = join(tables: {s: m2s_sent, r: m2s_received}, on: ["sensor"])
  |> filter(fn: (r) => exists r.sent_timestamp and exists r.received_timestamp)
  |> map(fn: (r) => ({
    _time: r._time_r,
    sensor: r.sensor,
    direction: "M2S",
    latencia_ms: float(v: (r.received_timestamp - r.sent_timestamp)),
    time_diff_ns: int(v: r._time_r) - int(v: r._time_s)
  }))
  |> filter(fn: (r) => r.latencia_ms >= 0.0 and r.latencia_ms < 1000.0)
  |> filter(fn: (r) => r.time_diff_ns >= 0 and r.time_diff_ns < 30000000000)
  |> group(columns: ["sensor", "sent_timestamp"])
  |> min(column: "latencia_ms")
  |> group()
  |> histogram(
      column: "latencia_ms",
      upperBoundColumn: "le",
      countColumn: "_value",
      bins: [0.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 150.0, 200.0, 300.0, 500.0, 1000.0]
    )
  |> map(fn: (r) => ({ r with direction: "M2S" }))

// Combined Histogram for Comparison
union(tables: [s2m_histogram, m2s_histogram])
  |> yield(name: "latencia_distribution_comparison")

// Percentile Comparison
s2m_percentiles = join(tables: {s: s2m_sent, r: s2m_received}, on: ["sensor"])
  |> filter(fn: (r) => exists r.sent_timestamp and exists r.received_timestamp)
  |> map(fn: (r) => ({
    sensor: r.sensor,
    direction: "S2M",
    latencia_ms: float(v: (r.received_timestamp - r.sent_timestamp)),
    time_diff_ns: int(v: r._time_r) - int(v: r._time_s)
  }))
  |> filter(fn: (r) => r.latencia_ms >= 0.0 and r.latencia_ms < 1000.0)
  |> filter(fn: (r) => r.time_diff_ns >= 0 and r.time_diff_ns < 30000000000)
  |> group(columns: ["sensor", "sent_timestamp"])
  |> min(column: "latencia_ms")
  |> group()

m2s_percentiles = join(tables: {s: m2s_sent, r: m2s_received}, on: ["sensor"])
  |> filter(fn: (r) => exists r.sent_timestamp and exists r.received_timestamp)
  |> map(fn: (r) => ({
    sensor: r.sensor,
    direction: "M2S", 
    latencia_ms: float(v: (r.received_timestamp - r.sent_timestamp)),
    time_diff_ns: int(v: r._time_r) - int(v: r._time_s)
  }))
  |> filter(fn: (r) => r.latencia_ms >= 0.0 and r.latencia_ms < 1000.0)
  |> filter(fn: (r) => r.time_diff_ns >= 0 and r.time_diff_ns < 30000000000)
  |> group(columns: ["sensor", "sent_timestamp"])
  |> min(column: "latencia_ms")
  |> group()

// Calculate percentiles for both directions
s2m_p50 = s2m_percentiles |> quantile(column: "latencia_ms", q: 0.5) |> map(fn: (r) => ({ r with direction: "S2M", percentile: "P50" }))
s2m_p95 = s2m_percentiles |> quantile(column: "latencia_ms", q: 0.95) |> map(fn: (r) => ({ r with direction: "S2M", percentile: "P95" }))
s2m_p99 = s2m_percentiles |> quantile(column: "latencia_ms", q: 0.99) |> map(fn: (r) => ({ r with direction: "S2M", percentile: "P99" }))

m2s_p50 = m2s_percentiles |> quantile(column: "latencia_ms", q: 0.5) |> map(fn: (r) => ({ r with direction: "M2S", percentile: "P50" }))
m2s_p95 = m2s_percentiles |> quantile(column: "latencia_ms", q: 0.95) |> map(fn: (r) => ({ r with direction: "M2S", percentile: "P95" }))
m2s_p99 = m2s_percentiles |> quantile(column: "latencia_ms", q: 0.99) |> map(fn: (r) => ({ r with direction: "M2S", percentile: "P99" }))

union(tables: [s2m_p50, s2m_p95, s2m_p99, m2s_p50, m2s_p95, m2s_p99])
  |> yield(name: "latencia_percentiles_comparison")