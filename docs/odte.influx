```flux
// ODTE Flux report
// Computes per-device Timeliness (T), Reliability (R), Availability (A) and ODTE = T * R * A
// Contract:
// - _measurement == "device_data"
// - tag: sensor (device id)
// - fields: sent_timestamp, received_timestamp (numeric, ms since epoch)
// The orchestration script replaces the range(...) occurrence with explicit start/stop times
// and replaces the placeholder __SCENARIO_BUCKET__ with the scenario bucket name.

import "experimental"

DEADLINE_S = 0.2
AVAIL_INTERVAL = 10s

// Middts sent (when middts sent toward devices/simulators)
middts_sent = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "middts")
  |> filter(fn: (r) => r._field == "sent_timestamp")
  |> keep(columns: ["_time", "sensor", "_value"]) 
  |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, sent_ts_ms: float(v: r._value) }))

// Simulator received (when device/simulator records reception)
sim_recv = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "simulator")
  |> filter(fn: (r) => r._field == "received_timestamp")
  |> keep(columns: ["_time", "sensor", "_value"]) 
  |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, recv_ts_ms: float(v: r._value) }))

// Join by sensor and compute latency seconds
joined = join(tables: {m: middts_sent, s: sim_recv}, on: ["sensor"])
  |> map(fn: (r) => ({
    _time: r._time_s,
    sensor: r.sensor,
    sent_ts_s: r.sent_ts_ms / 1000.0,
    recv_ts_s: r.recv_ts_ms / 1000.0,
    latency_s: (r.recv_ts_ms - r.sent_ts_ms) / 1000.0
  }))
  |> filter(fn: (r) => exists r.sent_ts_s and exists r.recv_ts_s and r.latency_s >= 0.0)

// per-event minimal latency (dedupe)
per_event = joined
  |> group(columns: ["sensor", "recv_ts_s"]) 
  // Ensure the value to be reduced is in the _value column so aggregations are consistent
  |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, _value: r.latency_s }))
  |> min(column: "_value")
  // Restore a named field 'latency_s' from the aggregated _value
  |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, latency_s: float(v: r._value) }))

// Timeliness T: fraction of received events with latency <= DEADLINE_S
// Compute per-sensor on_time_count and received_count using union+pivot
on_time_tbl = per_event
  |> filter(fn: (r) => r.latency_s <= DEADLINE_S)
  |> group(columns: ["sensor"]) 
  // Normalize counting column into _value for consistent aggregation output
  |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, _value: r.latency_s }))
  |> count(column: "_value")
  |> map(fn: (r) => ({ sensor: r.sensor, stat: "on_time_count", value: int(v: r._value) }))

received_tbl = per_event
  |> group(columns: ["sensor"]) 
  // Ensure the counted column is in _value
  |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, _value: r.latency_s }))
  |> count(column: "_value")
  |> map(fn: (r) => ({ sensor: r.sensor, stat: "received_count", value: int(v: r._value) }))

counts = union(tables: [on_time_tbl, received_tbl])
  |> pivot(rowKey:["sensor"], columnKey:["stat"], valueColumn: "value")
  |> map(fn: (r) => ({ sensor: r.sensor, on_time_count: if exists r.on_time_count then r.on_time_count else 0, received_count: if exists r.received_count then r.received_count else 0 }))

T_table = counts
  |> map(fn: (r) => ({ sensor: r.sensor, T: if r.received_count > 0 then float(v: r.on_time_count) / float(v: r.received_count) else 0.0 }))

// Reliability R: received_count / sent_count
sent_tbl = middts_sent
  |> group(columns:["sensor"]) 
  // Normalize the sent timestamp into _value before counting
  |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, _value: r.sent_ts_ms }))
  |> count(column: "_value")
  |> map(fn: (r) => ({ sensor: r.sensor, stat: "sent_count", value: int(v: r._value) }))

// Compute R by pivoting sent_count and received_count
sentrecv = union(tables: [sent_tbl, received_tbl])
  |> pivot(rowKey:["sensor"], columnKey:["stat"], valueColumn: "value")
  |> map(fn: (r) => ({ sensor: r.sensor, sent_count: if exists r.sent_count then r.sent_count else 0, received_count: if exists r.received_count then r.received_count else 0 }))

R_table = sentrecv
  |> map(fn: (r) => ({ sensor: r.sensor, R: if r.sent_count > 0 then float(v: r.received_count) / float(v: r.sent_count) else 0.0 }))

// Availability A: fraction of windows with at least one event
availability = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> group(columns: ["sensor"]) 
  |> aggregateWindow(every: AVAIL_INTERVAL, fn: count, createEmpty: true)
  |> map(fn: (r) => ({ sensor: r.sensor, up: if r._value > 0 then 1.0 else 0.0 }))
  |> group(columns: ["sensor"]) |> mean(column: "up") |> map(fn: (r) => ({ _time: r._time, sensor: r.sensor, _value: r._value, A: float(v: r._value) }))

// Join metrics
// Join metrics sequentially (Flux joins accept only two parents at a time)
tr = join(tables: {t: T_table, r: R_table}, on: ["sensor"]) 
metrics = join(tables: {tr: tr, a: availability}, on: ["sensor"]) 
  |> map(fn: (r) => ({ sensor: r.sensor, T: r.T, R: r.R, A: r.A, ODTE: r.T * r.R * r.A }))

metrics |> yield(name: "ODTE_per_sensor")

// Optionally persist to scenario bucket: orchestration script should replace __SCENARIO_BUCKET__
metrics
  |> map(fn: (r) => ({ _time: now(), sensor: r.sensor, _field: "odte", _value: r.ODTE }))
  |> to(bucket: "__SCENARIO_BUCKET__")

// -----------------------------------------------------------------------------
// Debug helpers (commented):
// If ODTE is always zero, uncomment the yields below in the Data Explorer to
// inspect intermediate tables and find which component (T, R or A) is zero.
// -----------------------------------------------------------------------------
/*
// Inspect joined sent/recv pairs
joined |> yield(name: "joined_debug")

// Inspect per-event minimal latencies
per_event |> yield(name: "per_event_debug")

// Inspect counts and timeliness components
counts |> yield(name: "counts_debug")
T_table |> yield(name: "T_table_debug")

// Inspect send/receive pivot and reliability
sentrecv |> yield(name: "sentrecv_debug")
R_table |> yield(name: "R_table_debug")

// Inspect availability
availability |> yield(name: "availability_debug")

// Diagnostic combined table: show components side-by-side
diag_tr = join(tables: {t: T_table, r: R_table}, on: ["sensor"]) 
diag = join(tables: {d: diag_tr, a: availability}, on: ["sensor"]) 
  |> map(fn: (r) => ({ sensor: r.sensor, T: r.T, R: r.R, A: r.A, ODTE: r.T * r.R * r.A }))
diag |> yield(name: "diag_components")
*/

```
