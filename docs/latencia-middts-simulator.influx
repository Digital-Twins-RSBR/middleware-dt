```flux
# Flux script: latency from middts -> simulator
# Usage: paste into Influx Data Explorer (select bucket "data" and appropriate time range)

import "experimental"

// Use the explorer-selected bucket ("iot_data") so the script works when pasted
// into the Data Explorer without editing the bucket name.
// Read middts sent timestamps (events sent by middts toward devices/simulator)
middts_sent = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "middts")
  |> filter(fn: (r) => r._field == "sent_timestamp")
  // rename _value to sent_timestamp for clarity
  |> rename(columns: {_value: "sent_timestamp"})
  |> keep(columns: ["_time", "sensor", "sent_timestamp"])

// Diagnostic: how many middts_sent points per sensor in the selected range
middts_sent_counts = middts_sent
  |> group(columns: ["sensor"])
  |> count(column: "sent_timestamp")
  |> yield(name: "middts_sent_counts")

// Read simulator received timestamps (when simulator/device records reception)
// Read simulator received timestamps (when simulator/device records reception)
simulator_recv = from(bucket: "iot_data")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement == "device_data")
  |> filter(fn: (r) => r["source"] == "simulator")
  |> filter(fn: (r) => r._field == "received_timestamp")
  |> rename(columns: {_value: "received_timestamp"})
  |> keep(columns: ["_time", "sensor", "received_timestamp"])

// Diagnostic: how many simulator_recv points per sensor in the selected range
simulator_recv_counts = simulator_recv
  |> group(columns: ["sensor"])
  |> count(column: "received_timestamp")
  |> yield(name: "simulator_recv_counts")

// Join on sensor and compute latency (ms)
joined = join(tables: {m: middts_sent, s: simulator_recv}, on: ["sensor"]) 
  |> map(fn: (r) => ({
    _time: r._time_s,
    sensor: r.sensor,
    sent_timestamp: r.sent_timestamp,
    received_timestamp: r.received_timestamp,
    // Ensure numeric arithmetic: cast to float if values are numeric-like
    latency_ms: float(v: (r.received_timestamp - r.sent_timestamp))
  }))
  |> filter(fn: (r) => exists r.sent_timestamp and exists r.received_timestamp and r.latency_ms >= 0.0)

// Diagnostic: how many joined pairs per sensor (should be >0 for sensors that matched)
joined_counts = joined
  |> group(columns: ["sensor"]) 
  |> count(column: "latency_ms")
  |> yield(name: "joined_counts")

// Per-received-event: for each received_timestamp pick the smallest latency
// (this chooses the closest middts sent_timestamp that occurred before the receive)
per_event = joined
  |> group(columns: ["sensor", "received_timestamp"]) 
  |> min(column: "latency_ms")

// Output per-event latencies
per_event
  |> yield(name: "latency_per_event_middts_to_simulator")

// Aggregations: mean latency per sensor
per_event
  |> group(columns: ["sensor"]) 
  |> mean(column: "latency_ms")
  |> yield(name: "latency_mean_per_sensor_middts_to_simulator")

// Aggregations: 95th percentile per sensor
per_event
  |> group(columns: ["sensor"]) 
  |> quantile(column: "latency_ms", q: 0.95)
  |> yield(name: "latency_p95_per_sensor_middts_to_simulator")

# End of script
```
